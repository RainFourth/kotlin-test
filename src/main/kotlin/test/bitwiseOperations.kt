package test



/*
    ● shl(bits) – signed shift left (справа добавляются 0)
    ● shr(bits) – signed shift right (слева добавляются биты, равные биту знака)
    ● ushr(bits) – unsigned shift right (слева добавляются 0)
    ● and(bits) – bitwise and
    ● or(bits) – bitwise or
    ● xor(bits) – bitwise xor
    ● inv() – bitwise inversion

    They can be applied only to Int and Long.

    val x = (1 shl 2) and 0x000FF000
 */
fun bitwiseOperations(){
    var a = 6
    var b = -a
    println("binary $a: \t\t\t${a.toString(2).padStart(32,'0')}") // 00000000000000000000000000000110
    println("binary $b: \t\t\t${b.toUInt().toString(2).padStart(32,'0')}") // 11111111111111111111111111111010

    println()

    println("$a shr (>>) 2: \t\t${allBitsString(a shr 2)}") // 00000000000000000000000000000001
    println("$b shr (>>) 2: \t\t${allBitsString(b shr 2)}") // 11111111111111111111111111111110

    println()

    println("$a ushr (>>>) 2: \t${allBitsString(a ushr 2)}") // 00000000000000000000000000000001
    println("$b ushr (>>>) 2: \t${allBitsString(b ushr 2)}") // 00111111111111111111111111111110

    println()

    println("$a shl (<<) 2: \t\t${allBitsString(a shl 2)}") // 00000000000000000000000000011000
    println("$b shl (<<) 2: \t\t${allBitsString(b shl 2)}") // 11111111111111111111111111101000
    println("1 shl (<<) 2: \t\t${allBitsString(1 shl 2)}") // 00000000000000000000000000000100

    println()

    println("$a and (&) $b: \t\t${allBitsString(a and b)}") // 00000000000000000000000000000010
    println("$a or (|) $b: \t\t${allBitsString(a or b)}") // 11111111111111111111111111111110
    println("$a xor (^) $b: \t\t${allBitsString(a xor b)}") // 11111111111111111111111111111100

    println("$a.inv() (~): \t\t${allBitsString(a.inv())}") // 11111111111111111111111111111001
    println("$b.inv() (~): \t\t${allBitsString(b.inv())}") // 00000000000000000000000000000101

}

fun allBitsString(n:Int) = n.toUInt().toString(2).padStart(32,'0')
@JvmName("allBitsStringExt")
fun Int.allBitsString() = allBitsString(this)

// ТЕОРИЯ:
/*
    bin to hex:
    0000 - 0, 0001 - 1, 0010 - 2, 0011 - 3,
    0100 - 4, 0101 - 5, 0110 - 6, 0111 - 7,
    1000 - 8, 1001 - 9, 1010 - A, 1011 - B,
    1100 - C, 1101 - D, 1110 - E, 1111 - F.
 */
/*
    Хранение целых чисел в памяти компа:
    Левый бит - знак: 0 - плюс, 1 - минус.
    Остальные биты - значение.

    Если число положительное => левый бит 0 и число хранится в прямом коде:
    6 -> 110 -> 0x00000006
    Диапазон неотрицательных значений: 0..2^z-1
    где z - количество бит для хранения числа (Int - 32, Long - 64).
    Эти значения хранятся в прямом коде.


    Если число отрицательное => левый бит 1 и число хранится в дополнительном коде.
    Суть доп. кода в том, что (+a)+(-a)=0 => (-a)=0-(+a).
    Это удобно для машинных вычислений (комп не умеет отнимать - он умеет прибавлять отрицательное).
    Диапазон отрицательных значений: -2^z..-1
    Эти значения хранятся в доп. коде.

    6+(-6)=0 => (-6)=0-(+6):
    0x00000000 - 0x00000006 => 0xFFFFFFFA
    (0b00000000_00000000_00000000_00000000 - 0b00000000_00000000_00000000_00000006 => 0b11111111_11111111_11111111_11111010)
    Все левые биты, не входящие в диапазон битов (32) отбросились.
    Получился доп. код, соответсвующий числу -6 в памяти компа.

    Другой способ перевода:

    Найти код отрицательного числа для данного положительного:
        ● дано: 0x00000006 (прямой код) = 6
        ● -1: 0x00000005 (обратный код) = 5
        ● инверсия: 0xFFFFFFFA (доп код) = 4294967291 = -6 в памяти компа
        (-1 надо, т.к. в диапазон неотриц кодов входил 0, которого нет в диапазоне отриц кодов и нужно произвести сдвиг для соответствия значений)

    Получить положительное число из доп кода:
        ● дано: 0xFFFFFFFA (доп код) = 4294967291 = -6 в памяти компа
        ● инверсия: 0x00000005 (обратный код) = 5
        ● +1: 0x00000006 (прямой код) = 6
 */
